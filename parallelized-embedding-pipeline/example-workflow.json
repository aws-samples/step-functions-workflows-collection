{
  "title": "Parallelized Document Vectorization Pipeline",
  "description": "A serverless pipeline that processes documents in parallel and generates vector embeddings for similarity search using AWS Step Functions, Lambda, and Amazon Bedrock",
  "language": "Python",
  "simplicity": "3 - Application",
  "level": "400",
  "framework": "AWS SAM",
  "usecase": [
    "This sample project demonstrates how to build a scalable document vectorization pipeline using AWS Step Functions to orchestrate parallel processing of text, PDF, and Word documents. The pipeline extracts content, generates vector embeddings using Amazon Bedrock, and stores them in PostgreSQL with pgvector extension for similarity search.",
    "The state machine intelligently routes different document types to specialized Lambda functions for content extraction, then processes documents in parallel chunks to optimize performance and handle large files efficiently. Vector embeddings are generated using Amazon Bedrock's Titan embedding models.",
    "The pipeline supports true serverless architecture with automatic scaling, parallel processing capabilities, and robust error handling. It's designed for production workloads requiring high-throughput document processing and vector similarity search capabilities."
  ],
  "type": "Standard",
  "diagram": "/resources/workflow-diagram.png",
  "introBox": {
    "headline": "Scalable Document Vectorization with Parallel Processing",
    "text": [
      "This sample project demonstrates how to build a production-ready document vectorization pipeline using AWS Step Functions to orchestrate parallel processing of documents. The pipeline intelligently handles different document formats and processes them in parallel chunks for optimal performance.",
      "The state machine routes text, PDF, and Word documents to specialized Lambda functions for content extraction, then leverages parallel processing to generate vector embeddings using Amazon Bedrock's Titan models. All vectors are stored in PostgreSQL with pgvector extension for efficient similarity search.",
      "Key features include automatic document type detection, parallel chunk processing, serverless scaling, and comprehensive error handling - making it suitable for high-throughput production workloads."
    ]
  },
  "services": ["s3", "step functions", "lambda", "bedrock", "rds", "postgresql"],
  "gitHub": {
    "template": {
      "repoURL": "https://github.com/solaws/step-functions-workflows-collection/tree/main/parallelized-embedding-pipeline",
      "templateDir": "parallelized-embedding-pipeline",
      "templateFile": "template.yaml",
      "ASL": "statemachine.json"
    }
  },
  "resources": {
    "bullets": [
      {
        "text": "Amazon Bedrock",
        "link": "https://docs.aws.amazon.com/bedrock/latest/userguide/what-is-bedrock.html"
      },
      {
        "text": "AWS Step Functions",
        "link": "https://aws.amazon.com/step-functions/"
      },
      {
        "text": "AWS Lambda",
        "link": "https://aws.amazon.com/lambda/"
      },
      {
        "text": "Amazon RDS for PostgreSQL",
        "link": "https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_PostgreSQL.html"
      },
      {
        "text": "pgvector Extension",
        "link": "https://github.com/pgvector/pgvector"
      },
      {
        "text": "Amazon Titan Embedding Models",
        "link": "https://docs.aws.amazon.com/bedrock/latest/userguide/titan-embedding-models.html"
      },
      {
        "text": "AWS Serverless Application Model (SAM)",
        "link": "https://docs.aws.amazon.com/serverless-application-model/"
      }
    ]
  },
  "payloads": [
    {
      "headline": "Sample Text Document",
      "payloadURL": "test-documents/sample-text.txt"
    },
    {
      "headline": "Test Content Document", 
      "payloadURL": "test-documents/test-content.txt"
    }
  ],
  "deploy": {
    "text": [
      "Deploy the complete pipeline with database initialization: <code>./deploy-with-db-init.sh --region us-east-1</code>",
      "Or deploy infrastructure only: <code>sam build && sam deploy --guided</code>",
      "Then initialize the database: <code>./deploy-db-init.sh --region us-east-1</code>"
    ]
  },
  "cleanup": {
    "text": [
      "Delete the stack: <code>aws cloudformation delete-stack --stack-name vectorization-pipeline --region [YOUR-REGION]</code>",
      "Or use SAM: <code>sam delete</code>"
    ]
  },
  "definition": {
    "Comment": "A state machine that processes different types of documents and generates vector embeddings",
    "StartAt": "ParseS3String",
    "States": {
      "ParseS3String": {
        "Type": "Pass",
        "Parameters": {
          "s3Event.$": "States.StringToJson($.[0].body)"
        },
        "Next": "CheckFileType"
      },
      "CheckFileType": {
        "Type": "Choice",
        "Choices": [
          {
            "Variable": "$.s3Event.Records[0].s3.object.key",
            "StringMatches": "*.txt",
            "Next": "IngestTextFile"
          },
          {
            "Variable": "$.s3Event.Records[0].s3.object.key", 
            "StringMatches": "*.pdf",
            "Next": "IngestPDFFile"
          },
          {
            "Variable": "$.s3Event.Records[0].s3.object.key",
            "StringMatches": "*.docx", 
            "Next": "IngestDocFile"
          }
        ],
        "Default": "UnsupportedFileType"
      },
      "IngestTextFile": {
        "Type": "Task",
        "Resource": "arn:aws:states:::lambda:invoke",
        "Parameters": {
          "FunctionName": "IngestTextFunction",
          "Payload": {
            "SourceKey.$": "$.s3Event.Records[0].s3.object.key",
            "Bucket.$": "$.s3Event.Records[0].s3.bucket.name"
          }
        },
        "Next": "GetObjectMetadata"
      },
      "IngestPDFFile": {
        "Type": "Task", 
        "Resource": "arn:aws:states:::lambda:invoke",
        "Parameters": {
          "FunctionName": "IngestPDFFunction",
          "Payload": {
            "SourceKey.$": "$.s3Event.Records[0].s3.object.key",
            "Bucket.$": "$.s3Event.Records[0].s3.bucket.name"
          }
        },
        "Next": "GetObjectMetadata"
      },
      "IngestDocFile": {
        "Type": "Task",
        "Resource": "arn:aws:states:::lambda:invoke", 
        "Parameters": {
          "FunctionName": "IngestDocFunction",
          "Payload": {
            "SourceKey.$": "$.s3Event.Records[0].s3.object.key",
            "Bucket.$": "$.s3Event.Records[0].s3.bucket.name"
          }
        },
        "Next": "GetObjectMetadata"
      },
      "UnsupportedFileType": {
        "Type": "Fail",
        "Error": "UnsupportedFileType",
        "Cause": "Unsupported file type"
      },
      "GetObjectMetadata": {
        "Type": "Task",
        "Resource": "arn:aws:states:::aws-sdk:s3:headObject",
        "Parameters": {
          "Bucket.$": "$.Bucket",
          "Key.$": "$.SourceKey"
        },
        "ResultPath": "$.objectMetadata",
        "Next": "GetByteRanges"
      },
      "GetByteRanges": {
        "Type": "Task",
        "Resource": "arn:aws:states:::lambda:invoke",
        "Parameters": {
          "FunctionName": "GetByteRangesFunction",
          "Payload": {
            "objectSize.$": "$.objectMetadata.ContentLength"
          }
        },
        "ResultPath": "$.byteRanges",
        "Next": "ParallelProcessing"
      },
      "ParallelProcessing": {
        "Type": "Map",
        "InputPath": "$",
        "ItemsPath": "$.byteRanges.byteRanges",
        "ItemSelector": {
          "Bucket.$": "$.Bucket",
          "Key.$": "$.SourceKey", 
          "ByteRange.$": "$.Map.Item.Value"
        },
        "MaxConcurrency": 10,
        "ResultPath": "$.vectorizeResult",
        "ItemProcessor": {
          "ProcessorConfig": {
            "Mode": "INLINE"
          },
          "StartAt": "ProcessChunk",
          "States": {
            "ProcessChunk": {
              "Type": "Task",
              "Resource": "arn:aws:states:::lambda:invoke",
              "Parameters": {
                "FunctionName": "VectorizeFunction",
                "Payload": {
                  "Bucket.$": "$.Bucket",
                  "Key.$": "$.Key",
                  "ByteRangeStart.$": "$.ByteRange.start",
                  "ByteRangeEnd.$": "$.ByteRange.end"
                }
              },
              "End": true
            }
          }
        },
        "End": true
      }
    }
  },
  "authors": [
    {
      "name": "Solomon Ojo",
      "image": "/resources/solomon.jpg",
      "bio": "Solomon is a Solutions Architect supporting Federal System Integrators at AWS. He specializes in Generative AI solutions and serverless architectures, and is an active member of the AWS Machine Learning and Artificial Intelligence community. Outside of work, Solomon is passionate about serving his community and helping others leverage cloud technologies to solve complex problems.",
      "linkedin": ""
    },
    {
      "name": "Dave Horne",
      "image": "/resources/Dave.jpg",
      "bio": "Dave is a Sr. Solutions Architect supporting Federal System Integrators at AWS. He is based in Washington, DC and has 15 years of experience building, modernizing and integrating systems for Public Sector customers. Outside of work, Dave enjoys playing with his kids and hiking.",
      "linkedin": "davidjhorne"
    }
  ]
}
